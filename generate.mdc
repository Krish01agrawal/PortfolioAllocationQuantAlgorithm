# Code Generation Guidelines (NestJS/TypeScript)

## General Principles

### 1. Readability Over Cleverness
Write code that is immediately understandable:
```typescript
// ✅ GOOD - Clear intent
const fundsWithoutScores = funds.filter(f => f.sharpeRatio === undefined);

// ❌ BAD - Too clever with unnecessary reduce
const fundsWithoutScores = funds.reduce((acc, f) => !f.sharpeRatio ? [...acc, f] : acc, []);
```

### 2. Type Safety Everywhere
```typescript
// ✅ GOOD - Explicit types
function calculateZScore(value: number, mean: number, stddev: number): number {
  return (value - mean) / stddev;
}

// ❌ BAD - No types (implicit any)
function calculateZScore(value, mean, stddev) {
  return (value - mean) / stddev;
}
```

### 3. JSDoc for All Public Methods
```typescript
/**
 * Retrieve top N ranked funds from a category for a given risk profile.
 *
 * @param category - Fund category (e.g., "Large Cap Equity")
 * @param riskProfile - One of 4 risk profiles ("Aggressive Explorer", etc.)
 * @param n - Number of top funds to return
 * @returns Array of fund objects with scores and ranks
 * @throws {NotFoundException} If category or risk profile not found
 *
 * @example
 * ```typescript
 * const topFunds = await this.getTopNFunds("Large Cap Equity", "Balanced Achiever", 5);
 * console.log(topFunds.length); // 5
 * ```
 */
async getTopNFunds(category: string, riskProfile: string, n: number): Promise<FundScore[]> {
  // Implementation
}
```

### 4. Error Handling with Context
```typescript
// ✅ GOOD - Informative errors
try {
  const allocation = matrix[riskProfile][sipBucket];
} catch (error) {
  throw new NotFoundException(
    `No allocation found for riskProfile='${riskProfile}', sipBucket='${sipBucket}'. ` +
    `Available risk profiles: ${Object.keys(matrix).join(', ')}`
  );
}

// ❌ BAD - Generic error
const allocation = matrix[riskProfile][sipBucket]; // Throws generic error
```

### 5. Logging for Observability
```typescript
import { Logger } from '@nestjs/common';

@Injectable()
export class ZScoreCalculatorService {
  private readonly logger = new Logger(ZScoreCalculatorService.name);

  async calculate(categoryName: string): Promise<ZScore[]> {
    this.logger.log(`Starting Z-score calculation for ${categoryName}`);
    this.logger.debug(`Category mean: ${mean.toFixed(4)}, stddev: ${stddev.toFixed(4)}`);
    this.logger.warn(`Skipping ${nullCount} funds with missing ${param}`);
    this.logger.error(`Failed to calculate: ${error.message}`, error.stack);
    
    return scores;
  }
}
```

---

## NestJS Patterns

### 1. Dependency Injection
```typescript
// ✅ GOOD - Constructor injection
@Injectable()
export class PortfolioConstructionService {
  constructor(
    private readonly allocationEngine: AllocationEngineService,
    private readonly fundSelector: FundSelectorService,
    @InjectModel(MfScores.name) private mfScoresModel: Model<MfScores>,
  ) {}

  async buildPortfolio(dto: RecommendationRequestDto): Promise<Portfolio> {
    const allocation = await this.allocationEngine.getAllocation(dto);
    return this.fundSelector.selectFunds(allocation);
  }
}

// ❌ BAD - No DI, tight coupling
export class PortfolioConstructionService {
  async buildPortfolio(dto: RecommendationRequestDto): Promise<Portfolio> {
    const engine = new AllocationEngineService(); // Hard-coded dependency
    const allocation = await engine.getAllocation(dto);
    return allocation;
  }
}
```

### 2. DTOs for Validation
```typescript
import { IsString, IsNumber, Min, Max, IsEnum } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class RecommendationRequestDto {
  @ApiProperty({ example: 'Balanced Achiever', enum: ['Safety Seeker', 'Conservative Guardian', 'Balanced Achiever', 'Aggressive Explorer'] })
  @IsString()
  @IsEnum(['Safety Seeker', 'Conservative Guardian', 'Balanced Achiever', 'Aggressive Explorer'])
  riskProfile: string;

  @ApiProperty({ example: 25000, minimum: 500, maximum: 1000000 })
  @IsNumber()
  @Min(500)
  @Max(1000000)
  monthlySip: number;
}

// Usage in controller
@Post('recommend')
async recommend(@Body() dto: RecommendationRequestDto): Promise<Portfolio> {
  // DTO is automatically validated by class-validator
  return this.portfolioService.buildPortfolio(dto);
}
```

### 3. Mongoose Models
```typescript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'mfSchemeTrackRecord', timestamps: true })
export class MfSchemeTrackRecord extends Document {
  @Prop({ required: true, index: true })
  fundName: string;

  @Prop({ required: true, type: Types.ObjectId, ref: 'MfSchemeDataMonthwise' })
  latestDataId: Types.ObjectId;

  @Prop({ type: [{ timestamp: Date, mfDataId: Types.ObjectId }], default: [] })
  schemeMonthTrackList: { timestamp: Date; mfDataId: Types.ObjectId }[];
}

export const MfSchemeTrackRecordSchema = SchemaFactory.createForClass(MfSchemeTrackRecord);

// Add indexes
MfSchemeTrackRecordSchema.index({ fundName: 1 });
MfSchemeTrackRecordSchema.index({ schemeCode: 1 }, { unique: true });
```

### 4. Update References After Inserts
```typescript
// Insert snapshot into Collection 2
const snapshot = new this.mfSchemeDataModel({
  timestamp,
  fundId: fund._id,
  fundName: 'Axis Bluechip Fund',
  // ... 27 parameters
});
const savedSnapshot = await snapshot.save();

// Update Collection 1 with reference
await this.mfSchemeTrackRecordModel.updateOne(
  { _id: fund._id },
  {
    $push: {
      schemeMonthTrackList: {
        timestamp,
        mfDataId: savedSnapshot._id,
      },
    },
  },
);
```

---

## Scoring Engine Patterns

### 1. Load Config Once (Dependency Injection)
```typescript
@Injectable()
export class ZScoreCalculatorService {
  private directionalityConfig: DirectionalityConfig;

  constructor() {
    // Load config once in constructor
    const configPath = join(process.cwd(), 'src/config/json/directionality.json');
    this.directionalityConfig = JSON.parse(readFileSync(configPath, 'utf-8'));
  }

  // Methods use this.directionalityConfig
}
```

### 2. Handle Nulls Gracefully
```typescript
// Extract values, skipping nulls/undefined
const values: number[] = [];
for (const fund of funds) {
  const val = fund[param];
  if (val !== null && val !== undefined && !isNaN(val)) {
    values.push(val);
  }
}

// Check if enough data
if (values.length < 2) {
  this.logger.warn(`Insufficient data for ${param} in ${category} (only ${values.length} funds)`);
  continue; // Skip this parameter
}
```

### 3. Use Libraries for Statistics
```typescript
import { mean, standardDeviation } from 'simple-statistics';

// ✅ GOOD - Library handles edge cases
const categoryMean = mean(values);
const categoryStddev = standardDeviation(values); // Sample stddev by default

// ❌ BAD - Manual calculation prone to errors
const categoryMean = values.reduce((sum, v) => sum + v, 0) / values.length;
const variance = values.reduce((sum, v) => sum + Math.pow(v - categoryMean, 2), 0) / (values.length - 1);
const categoryStddev = Math.sqrt(variance);
```

### 4. Avoid Division by Zero
```typescript
let categoryStddev = standardDeviation(values);

if (categoryStddev === 0) {
  this.logger.warn(`All funds have same ${param} value in ${category} (stddev=0)`);
  categoryStddev = 1.0; // Avoid division by zero; Z-scores will be 0
}

const zScore = (directionalValue - categoryMean) / categoryStddev;
```

---

## Portfolio Construction Patterns

### 1. Validate Inputs First
```typescript
@Injectable()
export class PortfolioConstructionService {
  async buildPortfolio(dto: RecommendationRequestDto): Promise<Portfolio> {
    // DTOs handle validation, but add business logic checks
    const sipBucket = this.getSipBucket(dto.monthlySip);
    
    if (!this.allocationMatrix[dto.riskProfile]) {
      throw new NotFoundException(`Risk profile '${dto.riskProfile}' not found`);
    }
    
    if (!this.allocationMatrix[dto.riskProfile][sipBucket]) {
      throw new NotFoundException(`No allocation for ${dto.riskProfile} + ${sipBucket}`);
    }
    
    // Proceed with construction
    // ...
  }
}
```

### 2. Apply Constraints in Order
```typescript
async buildPortfolio(dto: RecommendationRequestDto): Promise<Portfolio> {
  // 1. Fetch top funds
  let portfolio = await this.fetchTopFunds(allocation, dto.riskProfile);

  // 2. Apply SIP minimums
  portfolio = this.applySipMinimums(portfolio);

  // 3. Enforce AMC diversification
  portfolio = await this.enforceAmcDiversity(portfolio);

  // 4. Round amounts
  portfolio = this.roundAmounts(portfolio);

  // 5. Allocate residuals
  portfolio = this.allocateResiduals(portfolio, dto.monthlySip);

  return portfolio;
}
```

### 3. Use Interfaces for Type Safety
```typescript
interface CategoryAllocation {
  percentage: number;
  numSchemes: number;
}

interface AllocationMatrix {
  [riskProfile: string]: {
    [sipBucket: string]: {
      [category: string]: CategoryAllocation;
    };
  };
}

// Load with type checking
const matrix: AllocationMatrix = JSON.parse(
  readFileSync('src/config/json/allocation-matrix.json', 'utf-8')
);
```

---

## Controller Patterns

### 1. Use Decorators for Routing
```typescript
import { Controller, Post, Body, Get, Param, HttpCode, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';

@ApiTags('Portfolio')
@Controller('api/portfolio')
export class PortfolioController {
  constructor(private readonly portfolioService: PortfolioConstructionService) {}

  @Post('recommend')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Get portfolio recommendation' })
  @ApiResponse({ status: 200, description: 'Portfolio generated successfully', type: PortfolioResponseDto })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  async recommend(@Body() dto: RecommendationRequestDto): Promise<PortfolioResponseDto> {
    return this.portfolioService.buildPortfolio(dto);
  }

  @Get(':userId')
  @ApiOperation({ summary: 'Get user portfolio' })
  async getPortfolio(@Param('userId') userId: string): Promise<Portfolio> {
    return this.portfolioService.getPortfolio(userId);
  }
}
```

### 2. Use Pipes for Transformation
```typescript
import { ParseIntPipe, ValidationPipe } from '@nestjs/common';

@Get(':id')
async getFund(@Param('id', ParseIntPipe) id: number): Promise<Fund> {
  // id is automatically converted to number
  return this.fundService.findOne(id);
}

// Global validation pipe (in main.ts)
app.useGlobalPipes(new ValidationPipe({
  whitelist: true,  // Strip unknown properties
  forbidNonWhitelisted: true,  // Throw error on unknown properties
  transform: true,  // Auto-transform to DTO types
}));
```

### 3. Use Guards for Authentication
```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = request.headers.authorization?.split(' ')[1];
    
    try {
      const payload = this.jwtService.verify(token);
      request.user = payload;
      return true;
    } catch {
      return false;
    }
  }
}

// Usage
@Post('recommend')
@UseGuards(JwtAuthGuard)
async recommend(@Body() dto: RecommendationRequestDto): Promise<Portfolio> {
  // Only authenticated users can access
  return this.portfolioService.buildPortfolio(dto);
}
```

---

## Testing Patterns

### 1. Use Jest for Unit Tests
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { ZScoreCalculatorService } from './z-score-calculator.service';

describe('ZScoreCalculatorService', () => {
  let service: ZScoreCalculatorService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ZScoreCalculatorService],
    }).compile();

    service = module.get<ZScoreCalculatorService>(ZScoreCalculatorService);
  });

  it('should calculate Z-scores correctly', () => {
    const values = [10, 12, 14, 16, 18];
    const mean = 14;
    const stddev = Math.sqrt(10);
    
    const zScore = service['calculateZScore'](14, mean, stddev);
    expect(zScore).toBeCloseTo(0, 2);
  });

  it('should handle zero stddev', () => {
    const values = [10, 10, 10];
    // Should set stddev to 1.0 to avoid division by zero
    // Test implementation
  });
});
```

### 2. Mock External Dependencies
```typescript
import { getModelToken } from '@nestjs/mongoose';

describe('PortfolioConstructionService', () => {
  let service: PortfolioConstructionService;
  let mockModel: any;

  beforeEach(async () => {
    mockModel = {
      findOne: jest.fn(),
      find: jest.fn(),
      updateOne: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PortfolioConstructionService,
        {
          provide: getModelToken(MfScores.name),
          useValue: mockModel,
        },
      ],
    }).compile();

    service = module.get<PortfolioConstructionService>(PortfolioConstructionService);
  });

  it('should build portfolio successfully', async () => {
    mockModel.find.mockResolvedValue([/* mock funds */]);
    
    const dto = {
      riskProfile: 'Balanced Achiever',
      monthlySip: 25000,
    };
    
    const portfolio = await service.buildPortfolio(dto);
    expect(portfolio.funds.length).toBeGreaterThan(0);
  });
});
```

---

## File Organization

### 1. Module Structure
```
src/scoring-engine/
├── scoring-engine.module.ts       # Module definition
├── scoring-engine.service.ts      # Main service
├── z-score-calculator.service.ts  # Sub-service
├── group-scorer.service.ts        # Sub-service
├── composite-scorer.service.ts    # Sub-service
└── dto/
    └── scoring-result.dto.ts      # Data transfer objects
```

### 2. Separate Config from Code
```typescript
// ✅ GOOD - Config in JSON
const directionalityConfig = JSON.parse(
  readFileSync('src/config/json/directionality.json', 'utf-8')
);

// ❌ BAD - Hardcoded in TypeScript
const HIGHER_IS_BETTER = [
  'fiveYearCagrEquity',
  'sharpeRatio',
  // ...
];
```

---

## Performance Tips

### 1. Use Lean Queries
```typescript
// ✅ GOOD - Returns plain JS objects
const funds = await this.mfSchemeDataModel.find({ category }).lean();

// ❌ BAD - Returns Mongoose documents (heavier)
const funds = await this.mfSchemeDataModel.find({ category });
```

### 2. Use Aggregation for Complex Queries
```typescript
const trend = await this.mfScoresModel.aggregate([
  { $match: { categoryName: 'Large Cap Equity' } },
  { $unwind: '$mfDecScores' },
  { $match: { 'mfDecScores.fundId': fundId } },
  { $project: {
      timestamp: 1,
      rank: '$mfDecScores.rank',
      score: '$mfDecScores.compositeScore',
  }},
  { $sort: { timestamp: 1 } },
]);
```

### 3. Cache Expensive Computations
```typescript
import { CACHE_MANAGER, Inject } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class AllocationEngineService {
  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}

  async getAllocationMatrix(): Promise<AllocationMatrix> {
    const cached = await this.cacheManager.get<AllocationMatrix>('allocation-matrix');
    if (cached) return cached;

    const matrix = JSON.parse(readFileSync('...', 'utf-8'));
    await this.cacheManager.set('allocation-matrix', matrix, 3600); // 1 hour TTL
    return matrix;
  }
}
```

---

## Security Best Practices

### 1. Environment Variables
```typescript
// ✅ GOOD - ConfigService
@Injectable()
export class BseClientService {
  constructor(private configService: ConfigService) {
    this.apiKey = this.configService.get<string>('BSE_API_KEY');
  }
}

// ❌ BAD - Hardcoded secret
const BSE_API_KEY = 'abc123xyz456'; // NEVER!
```

### 2. Validate User Inputs
```typescript
// DTOs handle basic validation
export class RecommendationRequestDto {
  @IsNumber()
  @Min(500)
  @Max(1000000)
  monthlySip: number;
}

// Business logic adds extra checks
if (dto.monthlySip < 500) {
  throw new BadRequestException('SIP amount must be at least ₹500');
}
```

### 3. Sanitize Database Queries
```typescript
// ✅ GOOD - Parameterized query
const fund = await this.mfSchemeTrackRecordModel.findOne({ fundName: userInput });

// ❌ BAD - String concatenation (NoSQL injection risk)
const query = `{ fundName: "${userInput}" }`; // If userInput = '", $where: "1==1'
const fund = await this.mfSchemeTrackRecordModel.findOne(eval(query));
```

---

**Last Updated**: October 6, 2025 (Updated for NestJS)
