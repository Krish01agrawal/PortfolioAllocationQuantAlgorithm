# Scoring Engine Context (NestJS/TypeScript)

## Core Algorithm Knowledge

### Z-Score Calculation
When working with scoring logic, remember:

1. **Category Isolation**: Z-scores are ALWAYS calculated per category (Large Cap funds only compete with Large Cap, not with Debt funds)

2. **Directionality First**: Before calculating mean/stddev, apply directionality:
   - **Higher is better**: Use value as-is (CAGR, Sharpe, Alpha, AUM, fund reputation)
   - **Lower is better**: Multiply by -1 (Beta, StdDev, Expense Ratio, Drawdown, Recovery Period)

3. **Formula**:
   ```typescript
   const directionalValue = lowerIsBetter.includes(param) ? -rawValue : rawValue;
   const categoryMean = mean(directionalValues);
   const categoryStddev = standardDeviation(directionalValues);
   const zScore = (directionalValue - categoryMean) / categoryStddev;
   ```

4. **Handle Edge Cases**:
   - If category has <3 funds: Skip Z-score calculation (log warning)
   - If stddev = 0 (all funds same value): Set stddev = 1.0 to avoid division by zero
   - If parameter is null/undefined: Skip this fund for this parameter only

### Group Scoring
27 parameters are grouped into 8 categories:

1. **returns_growth** (3 params): 5Y CAGR equity, 5Y CAGR debt/hybrid, 3Y rolling consistency
2. **risk_adjusted** (4 params): Sharpe, Sortino, Alpha, Beta
3. **volatility_drawdown** (4 params): Std Dev equity/debt, Max Drawdown, Recovery Period
4. **expense_aum** (4 params): Expense ratio equity/debt, AUM equity/debt
5. **downside_liquidity** (2 params): Downside capture ratio, Liquidity risk
6. **fund_house_mgr** (4 params): Fund house reputation, Manager tenure, Track record, AMC risk mgmt
7. **discipline_turnover** (3 params): Turnover ratio, Concentration/sector fit, Style fit
8. **esg_forward** (6 params): ESG governance, Benchmark consistency, Peer comparison, Tax efficiency, Innovation, Risk mitigation

**Group Score** = Average of Z-scores within that group (ignore nulls)

### Composite Scoring
Final score varies by risk profile due to different weightage:

```python
# Aggressive Explorer weights
{
  'returns_growth': 0.25,
  'risk_adjusted': 0.15,
  'volatility_drawdown': 0.10,
  'expense_aum': 0.10,
  'downside_liquidity': 0.05,
  'fund_house_mgr': 0.10,
  'discipline_turnover': 0.10,
  'esg_forward': 0.15
}

# Safety Seeker weights (different priorities)
{
  'returns_growth': 0.10,
  'risk_adjusted': 0.10,
  'volatility_drawdown': 0.20,  # Higher focus on stability
  'expense_aum': 0.20,
  'downside_liquidity': 0.15,
  'fund_house_mgr': 0.10,
  'discipline_turnover': 0.10,
  'esg_forward': 0.05
}
```

**Composite Score** = Σ(group_score × weight) for all 8 groups

### Ranking
Within each category:
1. Sort funds by composite_score DESC
2. Assign rank: 1, 2, 3, ...
3. Store in Collection 4 (mf_scores)

## Code Patterns (TypeScript/NestJS)

### When implementing Z-score calculator:
```typescript
// ALWAYS load directionality config in constructor
constructor() {
  const configPath = join(process.cwd(), 'src/config/json/directionality.json');
  this.directionalityConfig = JSON.parse(readFileSync(configPath, 'utf-8'));
}

// ALWAYS check category size
const funds = await this.mfSchemeDataModel.find({ fundCategory: categoryName }).lean();
if (funds.length < 3) {
  this.logger.warn(`Skipping ${categoryName}: only ${funds.length} funds`);
  return [];
}

// ALWAYS handle null/undefined values
const values = funds
  .map(f => f[param])
  .filter(v => v !== null && v !== undefined && !isNaN(v));
```

### When implementing group scorer:
```typescript
// ALWAYS load weightage config
const configPath = join(process.cwd(), 'src/config/json/weightage.json');
const config = JSON.parse(readFileSync(configPath, 'utf-8'));
const groups = config.parameterGroups;

// ALWAYS average only non-null Z-scores
const groupScore = mean(
  Object.values(zScores).filter(z => z !== null && z !== undefined)
);
```

## Testing Guidelines

### Critical Test Cases:
1. Category with exactly 3 funds (minimum)
2. Category with 1 fund (should skip)
3. Parameter where all funds have same value (stddev=0)
4. Parameter null for all funds in category
5. Fund missing 50% of parameters (partial scoring)

### Expected Outputs:
- Z-scores range: typically -3 to +3 (68% of funds within -1 to +1)
- Group scores range: similar to Z-scores
- Composite scores: typically 0.5 to 2.0 for top-ranked funds

## Common Pitfalls

1. ❌ **DON'T** calculate Z-scores across all funds (must be per category)
2. ❌ **DON'T** forget directionality (expense ratio as-is will favor expensive funds)
3. ❌ **DON'T** use population stddev (use sample stddev with ddof=1)
4. ❌ **DON'T** store Z-scores in Collection 2 (raw data) - they belong in Collection 4 (computed)

## Collection References

- **Input**: Collection 2 (mf_scheme_data_monthwise) - raw parameters
- **Output**: Collection 4 (mf_scores) - ranked funds with Z-scores + group scores
- **Config**: `src/config/directionality.json`, `src/config/weightage.json`

## Related Files (NestJS)

- `src/scoring-engine/z-score-calculator.service.ts`
- `src/scoring-engine/group-scorer.service.ts`
- `src/scoring-engine/composite-scorer.service.ts`
- `src/scoring-engine/ranker.service.ts`
- `src/schemas/mf-scheme-data-monthwise.schema.ts`
- `src/schemas/mf-scores.schema.ts`
