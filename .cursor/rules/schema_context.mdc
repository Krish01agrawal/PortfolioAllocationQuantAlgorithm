# Database Schema Context (Mongoose/NestJS)

## Architecture Philosophy

**Time-Series with References Design**

We use 4 Mongoose schemas in 2 pairs:
1. **Raw Data Pair**: Collection 1 (master registry) ↔ Collection 2 (time-series snapshots)
2. **Computed Data Pair**: Collection 3 (category registry) ↔ Collection 4 (time-series scores)

## Why This Design?

### Benefits:
✅ **No Data Duplication**: Fund metadata stored once in Collection 1  
✅ **Historical Tracking**: All past months preserved for trend analysis  
✅ **Fast Queries**: ObjectId references + indexes enable efficient joins  
✅ **Separation of Concerns**: Raw vs computed data isolated  
✅ **Scalability**: Can handle 10+ years of monthly snapshots  
✅ **Type Safety**: Mongoose schemas + TypeScript interfaces provide compile-time checks

### vs Embedded Design:
❌ Embedding all monthly data in one document → bloated documents (>16MB limit)  
❌ Hard to query specific months  
❌ Difficult to rebuild scores without touching raw data  

## Collection Details

### Collection 1: `mf_scheme_track_record`

**Purpose**: Master fund registry (like a phonebook)  
**Lifespan**: Permanent (funds added, never deleted)  
**Growth**: Slow (~50-100 new funds/year)  

**Key Fields**:
```javascript
{
  _id: ObjectId,
  fund_name: String,  // Primary identifier
  amc: String,
  scheme_code: String,  // BSE/AMFI code for trading
  schemeMonthTrackList: [
    {
      timestamp: ISODate,  // Month of snapshot
      mfDataId: ObjectId   // → Collection 2
    }
  ]
}
```

**Indexes**:
```javascript
db.mf_scheme_track_record.createIndex({ "fund_name": 1 })
db.mf_scheme_track_record.createIndex({ "scheme_code": 1 }, { unique: true })
```

**Query Patterns**:
```javascript
// Get fund by name
db.mf_scheme_track_record.findOne({ "fund_name": "Axis Bluechip Fund" })

// Get all funds for an AMC
db.mf_scheme_track_record.find({ "amc": "Axis Mutual Fund" })
```

---

### Collection 2: `mf_scheme_data_monthwise`

**Purpose**: Time-series of all 27 parameters per fund per month  
**Lifespan**: Grows forever (never delete for historical analysis)  
**Growth**: Fast (1,800 docs/month = 21,600/year)  

**Key Fields**:
```javascript
{
  _id: ObjectId,
  timestamp: ISODate,  // Month-start date (2025-10-01)
  fundId: ObjectId,    // → Collection 1
  fund_name: String,
  fund_category: String,  // "Large Cap Equity"
  
  // 27 parameters from Morningstar
  five_year_cagr_equity: Float,
  sharpe_ratio: Float,
  expense_ratio_equity: Float,
  // ... 24 more
}
```

**Indexes**:
```javascript
// Most common query: Get latest data for a category
db.mf_scheme_data_monthwise.createIndex({ 
  "fund_category": 1, 
  "timestamp": -1 
})

// Get all snapshots for a fund (historical trend)
db.mf_scheme_data_monthwise.createIndex({ "fundId": 1, "timestamp": -1 })
```

**Query Patterns**:
```javascript
// Get latest month's data for all Large Cap funds
db.mf_scheme_data_monthwise.find({
  "fund_category": "Large Cap Equity",
  "timestamp": ISODate("2025-10-01")
})

// Get historical data for one fund
db.mf_scheme_data_monthwise.find({
  "fundId": ObjectId("..."),
  "timestamp": { $gte: ISODate("2025-04-01") }
}).sort({ "timestamp": 1 })
```

---

### Collection 3: `category_score`

**Purpose**: Master list of 12 fund categories  
**Lifespan**: Permanent (fixed list)  
**Growth**: None (12 categories are static)  

**Categories**:
```javascript
[
  "Large Cap Equity",
  "Mid Cap Equity",
  "Small Cap Equity",
  "Flexi-Cap / MultiCap",
  "Index / ETF",
  "International Equity",
  "Hybrid – Conservative",
  "Hybrid – Equity-Oriented",
  "Debt – Corporate",
  "Debt – Short/Ultra Short",
  "Debt – Banking / PSU",
  "Debt – Gilt"
]
```

**Key Fields**:
```javascript
{
  _id: ObjectId,
  category_name: String,  // "Large Cap Equity"
  category_code: String,  // "LARGE_CAP" (enum-friendly)
  mf_scores_plan_list: [
    {
      timestamp: ISODate,
      MF_Scores_id: ObjectId  // → Collection 4
    }
  ]
}
```

**Indexes**:
```javascript
db.category_score.createIndex({ "category_name": 1 }, { unique: true })
```

---

### Collection 4: `mf_scores`

**Purpose**: Time-series of ranked/scored funds per category **FOR ALL RISK PROFILES**  
**Lifespan**: Grows monthly  
**Growth**: Medium (12 docs/month = 144/year, ONE per category per month)  

**Key Fields**:
```javascript
{
  _id: ObjectId,
  timestamp: ISODate,  // Month of scoring
  category_name: String,  // "Large Cap Equity"
  mutual_fund_category_id: ObjectId,  // → Collection 3
  
  // =====================================
  // SECTION 1: Category-Level Statistics
  // =====================================
  category_stats: {
    total_funds: Int,  // e.g., 50 funds in Large Cap
    parameters: {
      '5Y_CAGR': { mean: Float, stdev: Float },
      'Sharpe_3Y': { mean: Float, stdev: Float },
      // ... all 27 parameters
    }
  },
  
  // =====================================
  // SECTION 2: Fund-Level Data (Risk-Agnostic)
  // =====================================
  funds_data: [
    {
      fund_id: ObjectId,  // → Collection 1
      fund_name: String,
      
      // Raw values from Morningstar (AS-IS)
      raw_values: {
        '5Y_CAGR': Float,        // 18.86
        'Sharpe_3Y': Float,      // 1.22
        'Fund_House': String,    // "Tier 1"
        'Manager_Record': String, // "Excellent"
        // ... all 27 parameters
      },
      
      // Points assigned (Step 1)
      points: {
        '5Y_CAGR': Int,          // 10 (≥15%)
        'Sharpe_3Y': Int,        // 10 (≥1.2)
        'Fund_House': Int,       // 10 ("Tier 1")
        'Manager_Record': Int,   // 10 ("Excellent")
        // ... all 27 parameters
      },
      
      // Z-scores (Step 3, SAME across all risk profiles)
      z_scores: {
        '5Y_CAGR_zscore': Float,      // 1.22
        'Sharpe_3Y_zscore': Float,    // 1.20
        'Fund_House_zscore': Float,   // 1.55
        'Manager_Record_zscore': Float, // 1.61
        // ... all 27 parameters
      }
    }
    // ... all funds in category
  ],
  
  // =====================================
  // SECTION 3: Risk-Profile-Specific Scores (Step 4)
  // ⚠️ CRITICAL: Different scores & ranks for each risk profile!
  // =====================================
  risk_profile_scores: [
    {
      risk_profile: "Aggressive Explorer",
      weighted_scores: [
        {
          fund_id: ObjectId,
          fund_name: "Nippon India Large Cap Fund",
          composite_score: 87.5,  // High (returns weighted more)
          rank: 1
        },
        {
          fund_id: ObjectId,
          fund_name: "ICICI Pru Bluechip Fund",
          composite_score: 82.1,
          rank: 3
        }
        // ... all funds sorted by composite_score DESC
      ]
    },
    {
      risk_profile: "Balanced Achiever",
      weighted_scores: [
        {
          fund_id: ObjectId,
          fund_name: "ICICI Pru Bluechip Fund",  // Different ranking!
          composite_score: 84.7,
          rank: 1
        },
        {
          fund_id: ObjectId,
          fund_name: "Nippon India Large Cap Fund",
          composite_score: 83.2,
          rank: 2
        }
        // ... all funds sorted by composite_score DESC
      ]
    },
    {
      risk_profile: "Conservative Guardian",
      weighted_scores: [ /* ... */ ]
    },
    {
      risk_profile: "Safety Seeker",
      weighted_scores: [
        {
          fund_id: ObjectId,
          fund_name: "ICICI Pru Bluechip Fund",  // Different top fund!
          composite_score: 82.3,
          rank: 1
        },
        {
          fund_id: ObjectId,
          fund_name: "Axis Bluechip Fund",
          composite_score: 81.7,
          rank: 2
        },
        {
          fund_id: ObjectId,
          fund_name: "Nippon India Large Cap Fund",  // Lower rank
          composite_score: 79.1,
          rank: 3
        }
        // ... all funds sorted by composite_score DESC
      ]
    }
  ],
  
  createdAt: ISODate,
  processing_time_ms: Int,  // For monitoring
  status: String  // "completed", "failed"
}
```

**⚠️ Key Insight:**
- **ONE document per category per month** (not one per risk profile)
- **Contains scores for ALL 4 risk profiles** in `risk_profile_scores` array
- **Rankings differ by risk profile** (top fund for Aggressive ≠ top fund for Safety Seeker)
- **Z-scores are universal** (same across all risk profiles)
- **Composite scores are risk-specific** (different weights applied)

**Indexes**:
```javascript
// Get latest scores for a category
db.mf_scores.createIndex({ 
  "category_name": 1, 
  "timestamp": -1 
})

// Efficient filtering by risk profile
db.mf_scores.createIndex({ 
  "risk_profile_scores.risk_profile": 1 
})

// For fund-level queries
db.mf_scores.createIndex({ 
  "funds_data.fund_id": 1,
  "timestamp": -1
})
```

**Query Patterns**:
```javascript
// Get top 5 Large Cap funds for Balanced Achiever (latest month)
db.mf_scores.aggregate([
  { $match: { 
      "category_name": "Large Cap Equity",
      "timestamp": ISODate("2025-10-01")
  }},
  { $unwind: "$risk_profile_scores" },
  { $match: { 
      "risk_profile_scores.risk_profile": "Balanced Achiever"
  }},
  { $project: {
      scores: { $slice: ["$risk_profile_scores.weighted_scores", 5] }
  }}
])

// Get historical rank trend for a fund (across all risk profiles)
db.mf_scores.aggregate([
  { $match: { 
      "category_name": "Large Cap Equity",
      "timestamp": { $gte: ISODate("2024-01-01") }
  }},
  { $unwind: "$risk_profile_scores" },
  { $unwind: "$risk_profile_scores.weighted_scores" },
  { $match: { 
      "risk_profile_scores.weighted_scores.fund_id": ObjectId("...")
  }},
  { $project: {
      timestamp: 1,
      risk_profile: "$risk_profile_scores.risk_profile",
      rank: "$risk_profile_scores.weighted_scores.rank",
      score: "$risk_profile_scores.weighted_scores.composite_score"
  }},
  { $sort: { timestamp: 1 } }
])

// Compare a fund's rank across all risk profiles (current month)
db.mf_scores.aggregate([
  { $match: { 
      "category_name": "Large Cap Equity",
      "timestamp": ISODate("2025-10-01")
  }},
  { $unwind: "$risk_profile_scores" },
  { $unwind: "$risk_profile_scores.weighted_scores" },
  { $match: { 
      "risk_profile_scores.weighted_scores.fund_name": "Nippon India Large Cap Fund"
  }},
  { $project: {
      risk_profile: "$risk_profile_scores.risk_profile",
      rank: "$risk_profile_scores.weighted_scores.rank",
      score: "$risk_profile_scores.weighted_scores.composite_score"
  }}
])
// Output:
// [
//   { risk_profile: "Aggressive Explorer", rank: 1, score: 87.5 },
//   { risk_profile: "Balanced Achiever", rank: 2, score: 83.2 },
//   { risk_profile: "Conservative Guardian", rank: 4, score: 78.9 },
//   { risk_profile: "Safety Seeker", rank: 3, score: 79.1 }
// ]
```

## Relationships

```
Collection 1 (mf_scheme_track_record)
    ↓ 1:N (one fund, many monthly snapshots)
Collection 2 (mf_scheme_data_monthwise)

Collection 3 (category_score)
    ↓ 1:N (one category, many monthly score lists)
Collection 4 (mf_scores)
    ↓ N:1 (each score references back to fund)
Collection 1 (via fund_id)
```

## Data Flow

```
Monthly Ingestion:
1. Parse Morningstar JSON
2. Upsert Collection 1 (if new fund)
3. Insert Collection 2 (new snapshot)
4. Update Collection 1.schemeMonthTrackList (reference)

Monthly Scoring:
1. Read Collection 2 (raw parameters)
2. Calculate Z-scores per category
3. Group + weight → composite scores
4. Rank funds
5. Insert Collection 4 (new score snapshot)
6. Update Collection 3.mf_scores_plan_list (reference)
```

## Code Patterns (Mongoose/TypeScript)

### When querying latest data:
```typescript
// ALWAYS use timestamp + category together + lean() for performance
const latestData = await this.mfSchemeDataModel.find({
  timestamp: latestTimestamp,
  fundCategory: categoryName
}).lean();
```

### When inserting new snapshots:
```typescript
// ALWAYS update reference in master collection
const snapshot = new this.mfSchemeDataModel(data);
const savedSnapshot = await snapshot.save();

await this.mfSchemeTrackRecordModel.updateOne(
  { _id: fundId },
  {
    $push: {
      schemeMonthTrackList: {
        timestamp,
        mfDataId: savedSnapshot._id,
      },
    },
  },
);
```

### When joining collections:
```typescript
// Use aggregation pipeline or populate()
const pipeline = [
  { $match: { categoryName: 'Large Cap Equity' } },
  {
    $lookup: {
      from: 'mfSchemeTrackRecord',
      localField: 'mfDecScores.fundId',
      foreignField: '_id',
      as: 'fundDetails',
    },
  },
];

const results = await this.mfScoresModel.aggregate(pipeline);

// Or use populate for simple joins
const scores = await this.mfScoresModel
  .findOne({ categoryName: 'Large Cap Equity' })
  .populate('mfDecScores.fundId');
```

## Migration Strategy

If schema changes:
1. **Add fields**: Just insert with new field (MongoDB is schemaless)
2. **Rename fields**: Use `$rename` aggregation
3. **Remove fields**: Use `$unset` (but don't delete historical data!)

## Backup Strategy

- **Frequency**: Daily automated backups (MongoDB Atlas Point-in-Time Recovery)
- **Retention**: 30 days rolling
- **Critical collections**: Collection 1 & 2 (raw data) - rest can be recomputed

## Related Files (NestJS/Mongoose)

- `src/schemas/mf-scheme-track-record.schema.ts`
- `src/schemas/mf-scheme-data-monthwise.schema.ts`
- `src/schemas/category-score.schema.ts`
- `src/schemas/mf-scores.schema.ts`
- `src/config/database.config.ts`
- `src/config/config.module.ts`
